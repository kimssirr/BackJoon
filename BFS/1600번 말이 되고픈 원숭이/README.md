# 말이 되고픈 원숭이 (BOJ 1600)

### 요구사항
- W × H 격자에서 (0,0) → (W-1,H-1)까지 **최단 거리**를 구한다.
- 기본 이동은 상하좌우 4방향.
- 최대 K번까지 말 이동(8방향)을 사용할 수 있다.
- 장애물(1)은 이동 불가.
- 말 이동 사용 여부에 따라 **같은 칸도 다른 상태**로 취급해야 한다.

### 풀이

이 문제는 **상태를 포함한 BFS**로 해결한다.

1. 상태 정의
    - 좌표 `(x, y)` + 남은 말 이동 횟수 `h`
    - `Point(x, y, h)` 형태로 큐에서 관리한다.

2. 방문 / 거리 관리
    - `visited[x][y][h]`: 해당 좌표에 말 이동을 h번 남긴 상태로 방문했는지
    - `dist[x][y][h]`: 해당 상태까지의 최단 거리
    - 따라서 방문 배열과 거리 배열은 **3차원**으로 관리한다.

3. BFS 시작
    - 시작 상태 `(0,0,K)`를 큐에 넣고
    - `visited[0][0][K] = true`, `dist[0][0][K] = 0`

4. BFS 진행
    - 큐에서 하나를 꺼낸다.
    - 현재 위치가 `(W-1, H-1)`이면 해당 `dist`를 즉시 반환한다.

5. 이동 처리
    - **일반 이동(상하좌우 4방향)**
        - 말 이동 횟수 `h`는 그대로 유지
    - **말 이동(8방향)**
        - `h > 0`일 때만 가능
        - 다음 상태는 `h - 1`

6. 이동 가능 조건 (`isTrue`)
    - 격자 범위 내부
    - 장애물 아님
    - 해당 `(x, y, h)` 상태로 아직 방문하지 않음

7. BFS가 끝날 때까지 도착하지 못하면 `-1` 반환

### 포인트
- 같은 좌표라도 남은 말 이동 횟수(h)가 다르면 다른 상태다.
- 따라서 `visited[x][y][h]`, `dist[x][y][h]` 형태가 필수다.
- 말 이동을 쓰는 순간 `h`를 감소시켜 상태를 분리한다.

### 시간복잡도
- 시간복잡도: **O(W × H × K)**
- 공간복잡도: **O(W × H × K)**

