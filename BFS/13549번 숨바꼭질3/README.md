# 숨바꼭질 3

### 요구사항
- 수빈이의 위치 N에서 동생의 위치 K까지 이동하는 **최단 시간**을 구한다.
- 이동 방법은 3가지이다.
    - X → X-1 (시간 +1)
    - X → X+1 (시간 +1)
    - X → X*2 (시간 +0)
- 위치 범위는 0 ≤ X ≤ 100000.

### 풀이

이 문제는 0-1 BFS이다.

1. 전역 변수로 시작 위치 `N`, 목표 위치 `K`, 거리 배열 `dist[]`를 사용한다.
    - `dist[x]`는 x 위치까지 도달하는 최소 시간을 의미한다.
    - 처음에는 모두 `INF`로 초기화한다.

2. BFS를 `ArrayDeque`로 관리한다.
    - 시작 위치 `N`을 큐에 넣고 `dist[N] = 0`으로 설정한다.

3. 큐에서 현재 위치 `now`를 하나 꺼낸다.
    - 만약 `now == K`이면, 현재까지의 `dist[now]`가 정답이므로 즉시 반환한다.

4. 현재 위치 기준으로 이동을 처리한다.
    - **now > K 인 경우**
        - 뒤로 가는 경우(X-1)만 고려한다.
    - **now ≤ K 인 경우**
        - X-1, X+1, X*2 세 가지 이동을 모두 고려한다.

5. 이동 처리 방식
    - X-1, X+1 이동
        - 비용이 1이므로  
          `dist[next] > dist[now] + 1` 일 때만 갱신
        - `addLast()`로 큐의 뒤에 삽입
    - X*2 이동
        - 비용이 0이므로  
          `dist[next] > dist[now]` 일 때 갱신
        - `addFirst()`로 큐의 앞에 삽입

6. 큐가 빌 때까지 반복하며,
    - 가장 먼저 K에 도달하는 순간의 시간이 최단 시간이다.

### 포인트
- 순간이동(X*2)은 비용이 0이므로 **Deque 앞쪽(addFirst)** 에 넣는다.
- 일반 이동은 비용이 1이므로 **뒤쪽(addLast)** 에 넣는다.
- 이 방식으로 우선순위 큐 없이 최단 시간을 보장한다.

### 시간복잡도
- 각 위치는 최대 한 번씩 최적 거리로 갱신된다.
- 전체 시간복잡도: **O(MAX)** 
- 공간복잡도: **O(MAX)**

