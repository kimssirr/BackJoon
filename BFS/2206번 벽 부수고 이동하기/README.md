# 벽 부수고 이동하기

### 요구사항
- n × m 격자에서 (0,0) → (n-1,m-1)까지 **최단 거리**를 구하는 문제.
- 이동 도중 **벽(1)을 단 한 번만 부술 수 있다**.
- 벽을 부순 상태와 안 부순 상태는 서로 다른 경로로 취급해야 하므로  
  `visited[x][y][2]` 형태의 3차원 방문 배열 사용.
    - `visited[x][y][0]`: 아직 벽을 부수지 않고 방문
    - `visited[x][y][1]`: 이미 벽을 부수고 방문

### 풀이

1. 입력으로 받은 n × m 크기만큼 `map`에 문자열을 char로 저장한다.  
   ('0' = 빈칸, '1' = 벽)

2. `visited[n][m][2]` 배열 생성  
   → 벽을 부순 상태/안 부순 상태를 따로 기록하기 위함.

3. BFS를 시작한다.
    - 시작 위치 (0,0)을 `len = 1`, `broken = 0`(벽 안 부숨) 상태로 큐에 삽입.

4. BFS 진행:
    - 큐에서 좌표 하나를 꺼내고, 목표 지점 `(n-1, m-1)`에 도달하면 즉시 `len` 반환.

5. 4방 탐색을 수행한다.
    - **A. 범위 검사**  
      nx, ny가 map 내부인지 확인.

    - **B. 다음 칸이 벽(`'1'`)인 경우**
        - 아직 벽을 부수지 않았고(`broken == 0`)  
          방문도 하지 않았다면  
          → 벽을 부순 상태 `broken = 1`로 바꿔 이동.
          ```text
          visited[nx][ny][1] = true
          queue.add(len+1, broken=1)
          ```

    - **C. 다음 칸이 빈칸(`'0'`)인 경우**
        - 현재 broken 상태 그대로 방문 처리.
          ```text
          visited[nx][ny][broken] = true
          queue.add(len+1, broken)
          ```

6. BFS가 끝날 때까지 목표에 도달하지 못하면 -1 출력.

### 시간복잡도
- 각 칸에 대해 **벽을 부순 상태 / 안 부순 상태 총 2가지로 방문할 수 있으므로**  
  최대 방문 수 = 2 × (n × m)
- BFS 전체 시간복잡도: **O(n × m)**
- 공간복잡도: **O(n × m × 2)**
