# 불

### 요구사항
- 건물 내부에서 불이 번지고, 상근이는 불을 피해서 탈출해야 한다.
- 불은 매 초마다 상하좌우로 번지고, 사람도 매 초마다 이동한다.
- 단, 불은 벽을 통과할 수 없고**, 사람 역시 벽, 불이 붙은 칸, 불이 막 번지려는 칸으로 이동할 수 없다.
- 상근이가 탈출하기 위해서는 단순히 가장자리에 ‘닿는 것’이 아니라, 경계를 벗어나는 좌표로 실제 이동해야 탈출이다.
- 탈출이 불가능하면 “IMPOSSIBLE”을 출력한다.

### 고민한 과정

1. 불과 사람을 어떻게 구분해야 할까?
   처음엔 불 BFS 따로, 사람 BFS 따로 생각할 수 있으나,  
   문제에서
   > “상근이가 있는 칸에 불이 옮겨옴과 동시에 이동할 수 있다.”  
   라고 되어 있어 **같은 시간 흐름 안에서 불이 먼저 번지고, 그 후 사람 이동**이 이루어져야 함을 알 수 있었다.

2. 따라서,
    - **불 BFS → 상근 BFS**  
      순서를 매 시간마다 반복해야 한다.  
      이 구조를 코드로 구현하기 위해  
      → **하나의 queue에 불과 사람을 함께 넣되**,  
      초기 단계에서는 **불 → 사람 순서로 넣어야 한다.**
      그래야 불이 먼저 확산된 뒤 사람이 이동하는 형태가 자연스럽게 BFS로 구현된다.

3. 그래서 Point 클래스에 `boolean isFire;`를 추가하여, 해당 점이 불인지 사람인지 구분하도록 구현한다.
4. 탈출 기준 판단
   사람이 단순히 건물의 가장자리(벽)에 ‘서는 것’이 탈출이 아니다.
   실제로 건물 밖으로 나가야 하므로
   → 좌표가 (1~w), (1~h) 범위를 벗어나야 탈출이다.

이를 단순하게 만들기 위해:
- 배열을 (w+2) × (h+2) 크기로 선언하고
  - 실제 건물은 [1~w][1~h] 범위에 존재
  - 사람이 (0 or w+1) 또는 (0 or h+1)로 이동하면 탈출 성공
  이런 구조로 구현했다.

### 풀이 요약

- map 크기를 **(w+2) × (h+2)** 로 만들어  
  실제 입력은 **[1~w][1~h]** 범위에 저장한다.
- queue를 하나 생성한 뒤
    - 먼저 모든 **불(*)** 을 넣고 `(isFire = true)`
    - **상근이(@)** 를 마지막에 넣는다 `(isFire = false)`
- BFS 진행
    - queue에서 poll
    - **불일 경우**
        - 벽/불이 아닌 칸으로 확산
        - map에 `'*'`로 표시
    - **사람일 경우**
        - 다음 칸이 건물 범위를 벗어나면 → 즉시 탈출, 현재 이동거리 반환
        - 방문하지 않았고, 벽/불이 아닌 칸만 이동
- BFS 종료까지 탈출 못 하면 `"IMPOSSIBLE"` 출력.

### 시간복잡도
- 모든 칸을 최대 1번씩 방문 → **O(w × h)**
- 테스트케이스 T개 → **O(T × w × h)**